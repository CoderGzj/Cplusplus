# 模板
C++提供两种模板机制:**函数模板**和**类模板** 

## 函数模板
**函数模板作用：**
建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个**虚拟的类型**来代表。

语法：
```c++
template<typename T>
函数声明或定义
template  ---  声明创建模板
typename  --- 表面其后面的符号是一种数据类型，可以用class代替
T    ---   通用的数据类型，名称可以替换，通常为大写字母
```
//利用模板提供通用的交换函数
```c++
template<typename T>
void mySwap(T& a, T& b)
{
	T temp = a;
	a = b;
	b = temp;
}
//利用模板实现交换
	//1、自动类型推导
	mySwap(a, b);

	//2、显示指定类型
	mySwap<int>(a, b);
```

**注意事项：**
* 自动类型推导，必须推导出一致的数据类型T,才可以使。
* 模板必须要确定出T的数据类型，才可以使用。

**普通函数与函数模板区别：**
* 普通函数调用时可以发生自动类型转换（隐式类型转换）
* 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
* 如果利用显示指定类型的方式，可以发生隐式类型转换

**调用规则如下：**
1. 如果函数模板和普通函数都可以实现，优先调用普通函数
2. 可以通过空模板参数列表来强制调用函数模板
3. 函数模板也可以发生重载
4. 如果函数模板可以产生更好的匹配,优先调用函数模板

## 类模板

**类模板作用：**
建立一个通用类，类中的成员 数据类型可以不具体制定，用一个**虚拟的类型**来代表。
**语法：** 
```c++
template<typename T>
类
```
**解释：**
template  ---  声明创建模板
typename  --- 表面其后面的符号是一种数据类型，可以用class代替
T    ---   通用的数据类型，名称可以替换，通常为大写字母

**类模板与函数模板区别主要有两点：**
1. 类模板没有自动类型推导的使用方式。只能用显示指定类型方式
2. 类模板在模板参数列表中可以有默认参数

**类模板中成员函数和普通类中成员函数创建时机是有区别的：**
* 普通类中的成员函数一开始就可以创建
* 类模板中的成员函数在调用时才创建

**类模板实例化出的对象，向函数传参的方式：**
一共有三种传入方式：
1. 指定传入的类型   --- 直接显示对象的数据类型
2. 参数模板化           --- 将对象中的参数变为模板进行传递
3. 整个类模板化       --- 将这个对象类型 模板化进行传递

**当类模板碰到继承时，需要注意一下几点：**
* 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型
* 如果不指定，编译器无法给子类分配内存
* 如果想灵活指定出父类中T的类型，子类也需变为类模板

**类模板中成员函数类外实现时，需要加上模板参数列表**

**掌握类模板成员函数分文件编写产生的问题以及解决方式**
* 类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到
* 解决：
* 解决方式1：直接包含.cpp源文件
* 解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制

**类模板配合友元函数的类内和类外实现**
全局函数类内实现 - 直接在类内声明友元即可
全局函数类外实现 - 需要提前让编译器知道全局函数的存在
